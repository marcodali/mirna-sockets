import WebSocket, { WebSocketServer } from 'ws'
import axios from 'axios'
import moment from 'moment'
import _ from 'lodash'
import jwt from 'jsonwebtoken'
import { v4 as uuidv4 } from 'uuid'

import { redis } from '../servers/api-socket.server.js'
import { socketProvider } from '../providers/socket.provider.js'
import { argumentToString, createGenericWebSocketServer } from './utils.js'

const dependencies = { axios, moment, _, jwt, uuidv4, WebSocket }

// Listening pub/sub redis events
export default async function listenerCreate(path) {
	const eventsPath = path + '/events'

	// If the socket already exists, we don't want to create it again
	if (socketProvider.getOneSocket(path)) {
		throw new Error('Socket already exists')
	}

	/**
	 * What is the Events UI?
	 * The Events UI is a nickname for the socket that
	 * is connected to the /username/project/events path.
	 * This socket is responsible for sending to the UI
	 * the console.log output generated on backend side
	 * by the dynamic user code execution.
	 */
	const sendStringMessageToEventUI = (message, _path) => {
		const wss = socketProvider?.getOneSocket(_path)?.getSocketServer()
		// Broadcast the message to all connected clients
		wss.clients.forEach((client) => {
			if (client.readyState === WebSocket.OPEN) {
				client.send(message)
			}
        })
	}

	const log_info = (...args) => {
		// First, we send the console.log output to the UI
		sendStringMessageToEventUI(args.map(argumentToString).join(' '), eventsPath)
		// Then, we print the console.log output to the backend console
		console.info(...args)
	}

	// Get the code as string from redis and replace console.log with log_info
	let code = (await redis.get(path))
		.replace(/console\.log/g, 'log_info')
		.replace(/console\.info/g, 'log_info')
		.replace(/console\.warn/g, 'log_info')
		.replace(/console\.error/g, 'log_info')
		.replace(/console\.debug/g, 'log_info')
	code = `return (async function() {
		${code}
	})()`

	/**
	 * Create another websocket server so we
	 * can send to the UI the console.log messages
	 * generated by the user code
	 */
	const userWrittenWSS = new WebSocketServer({ noServer: true })
	const userInterfaceEventsWSS = new WebSocketServer({ noServer: true })
	userInterfaceEventsWSS.on('connection', createGenericWebSocketServer(eventsPath))

	/**
	 * Both WebSocketServers are running now, but in order
	 * for them to be publicly accessible we must register
	 * them within the socketProvider
	 */
	const userSocket = socketProvider.createSocket(path, () => {}, userWrittenWSS)
	socketProvider.createSocket(eventsPath, () => {}, userInterfaceEventsWSS)

	// let's delay the execution of the dynamic code for 3 seconds
	setTimeout(async () => {
		console.info('DCE:OUTPUT for path', path)
		let codeRunner
		try {
			// Create a function from the code string
			codeRunner = new Function('wss', 'log_info', ...Object.keys(dependencies), code)
			// dynamic code execution (aka DCE) from the user input code starts here
			await codeRunner(userWrittenWSS, log_info, ...Object.values(dependencies))
		} catch (error) {
			redis.del(path)
			log_info('At dynamic code execution something went wrong')
			log_info(error.name, error.message)
			console.error('Full Error Stacktrace => ', error.stack)
			/**
			 * Delete the code from database because
			 * this code is not valid and we don't
			 * want to keep it in redis
			 */
			console.error(
				'Paso esto:',
				error.name,
				'\nY por esta razón:',
				error.message,
				'\nSe borrará de Redis el código del proyecto:',
				path,
			)
		}
		userSocket.setFn(codeRunner)
	}, 3 * 1000)
}
