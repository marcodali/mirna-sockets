import { WebSocketServer } from 'ws'

import { redis } from '../servers/api-socket.server.js'
import { socketProvider } from '../providers/socket.provider.js'
import { argumentToString, createGenericWebSocketServer } from './utils.js'

// Listening pub/sub redis events
export default async function listenerCreate(path) {
	const eventsPath = path + '/events'

	// If the socket already exists, we don't want to create it again
	if (socketProvider.getOneSocket(path)) {
		throw new Error('Socket already exists')
	}

	/**
	 * What is the Events UI?
	 * The Events UI is a nickname for the socket that
	 * is connected to the /username/project/events path.
	 * This socket is responsible for sending to the UI
	 * the console.log output generated on backend side
	 * by the dynamic user code execution.
	 */
	const sendStringMessageToEventUI = (message, _path) => {
		const wss = socketProvider?.getOneSocket(_path)?.getSocketServer()
		// Broadcast the message to all connected clients
		wss.clients.forEach((client) => {
			// TODO: check if the client is still connected
			try {
				client.send(message)
			} catch (error) {
				console.error('Error sending message to client', error)
			}
        })
	}

	const log_info = (...args) => {
		// First, we send the console.log output to the UI
		sendStringMessageToEventUI(args.map(argumentToString).join(' '), eventsPath)
		// Then, we print the console.log output to the backend console
		console.info(...args)
	}

	// Get the code as string from redis and replace console.log with log_info
	const code = (await redis.get(path)).replace(/console\.log/g, 'log_info')

	/**
	 * Create another websocket server so we
	 * can send to the UI the console.log messages
	 * generated by the user code
	 */
	const userWrittenWSS = new WebSocketServer({ noServer: true })
	const userInterfaceEventsWSS = new WebSocketServer({ noServer: true })
	userInterfaceEventsWSS.on('connection', createGenericWebSocketServer(eventsPath))

	/**
	 * Both WebSocketServers are running now, but in order
	 * for them to be publicly accessible we must register
	 * them within the socketProvider
	 */
	const userSocket = socketProvider.createSocket(path, () => {}, userWrittenWSS)
	socketProvider.createSocket(eventsPath, () => {}, userInterfaceEventsWSS)

	// let's delay the execution of the dynamic code for 3 seconds
	setTimeout(() => {
		console.info('DCE:OUTPUT for path', path)
		let codeRunner
		try {
			// Create a function from the code string
			codeRunner = new Function('wss', 'log_info', code)
			// dynamic code execution (aka DCE) from the user input code starts here
			codeRunner(userWrittenWSS, log_info)
		} catch (error) {
			redis.del(path)
			console.error('At dynamic code execution something went wrong')
			console.error(error.name, error.message)
			console.error('Full Error Stacktrace => ', error.stack)
			/**
			 * Delete the code from database because
			 * this code is not valid and we don't
			 * want to keep it in redis
			 */
			console.error(
				'Paso:',
				error.name,
				'Y por esta razón:',
				error.message,
				'Se borrará el código del proyecto',
				path,
				'De redis',
			)
		}
		userSocket.setFn(codeRunner)
	}, 3 * 1000)
}
